#!/usr/bin/env bash

# updates all git repos in directory

set -e -u
set -o pipefail

function elem_in () {
    local e match="$1"
    shift
    for e; do [[ "$e" == "$match" ]] && return 0; done
    return 1
}

function update_existing_repos ()
{
    local JOBOX_DIR="${1}"; shift
    local IGNORE_REPOS=(
        jobox-api
        olympus-mons
        Rysy-Core
    )
    local FORCE_DIRTY="${1}"; shift
    local GITARGS="${*}"

    for subdir in *; do
        { test -d "${subdir}/.git" && ! elem_in "${subdir}" "${IGNORE_REPOS[@]}"; } || continue
        cd "${subdir}"
        local repostatus
        repostatus=$(git status --short|grep -v '^??'||true)
        if [ -z "${repostatus}" ]; then
            printf "=========== UPDATING REPO %s ===========\n" "${subdir}"
            # we intentionally do not quote below to allow word splitting
            git ${GITARGS}
        elif $FORCE_DIRTY; then
            printf "=========== UPDATING REPO %s ===========\n" "${subdir}"
            # we intentionally do not quote below to allow word splitting
            git ${GITARGS}
        else
            printf "\033[31m=========== DIRTY REPO %s ==========\033[0m\n" "${subdir}"
        fi
        cd "${JOBOX_DIR}"
    done
}

function clone_any_missing_repos ()
{
    local ORGNAME="${1}"
    local IGNORE_REPOS=(
        nginx
        react-csv
    )
    local org_url
    local org_repos_url
    local repos_out
    local response_len
    local repo_names
    local dirname
    local page

    readonly ORGNAME
    readonly IGNORE_REPOS

    org_url="$(hub api | \
        jq -r '.organization_url' | \
        sed "s/{org}/${ORGNAME}/g")"
    org_repos_url="$(hub api "${org_url}" | \
        jq -r '.repos_url')?type=all&per_page=100"

    (( page=1 ))
    while : ; do
        repos_out="$(hub api "${org_repos_url}&page=${page}")"
        repo_names="$(jq -r '.[].clone_url' <<< "${repos_out}")"

        for repo in ${repo_names}; do
            dirname="$(basename "${repo}" .git)"
            if [ ! -d "${dirname}" ] && ! elem_in "${dirname}" "${IGNORE_REPOS[@]}"  ; then
                echo "MISSING ${dirname}; cloning"
                git clone "${repo}"
            fi
        done

        (( page+=1 ))
        response_len=$(jq '.|length' <<< "${repos_out}")
        [ "${response_len}" -ge 1 ] || break
    done
}

function main ()
{
    local JOBOX_DIR=${JOBOX:-$HOME/Documents/jobox-src}
    local JOBOX_TEAM_NAME="jobox-team"
    local FORCE_DIRTY=false
    local GITARGS

    readonly JOBOX_DIR
    readonly JOBOX_TEAM_NAME

    while getopts "fh-" opt; do
        case ${opt} in
            f)  # force operation on dirty repos
                FORCE_DIRTY=true
                shift
                ;;
            h)  # help message
                cat << EOF
Usage: $(basename "${0}") [OPTION]...
Options: -f: update dirty repos
         -h: show this help dialog
EOF
                exit 0
                ;;
            -)
                GITARGS="${*}"
                shift $#
                ;;
            ?)
                printf "Unknown option, exiting now\n" >&2
                exit 1
                ;;
        esac
    done

    if [ $# -ge 1 ] || [ -z "${GITARGS}" ]; then
        GITARGS="${*:-pull}"
    fi

    readonly FORCE_DIRTY
    readonly GITARGS

    cd "${JOBOX_DIR}"
    update_existing_repos "${JOBOX_DIR}" "${FORCE_DIRTY}" "${GITARGS}"

    if [ "${GITARGS}" == "pull" ]; then
        clone_any_missing_repos "${JOBOX_TEAM_NAME}"
    fi
}

if [ "${BASH_SOURCE[0]}" == "$0" ]; then
    main "$@"
fi
