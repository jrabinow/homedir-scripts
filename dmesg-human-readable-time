#!/usr/bin/env perl

eval '(exit $?0)' && eval 'exec perl -wS "$0" ${1+"$@"}'
  & eval 'exec perl -wS "$0" $argv:q'
    if 0;
# Derived from http://regerar.se/2011/02/21/human-readable-dmesg-timestamp/ and
# http://linuxaria.com/article/how-to-make-dmesg-timestamp-human-readable

use strict;

(my $ME = $0) =~ s|.*/||;

sub uptime ()
{
  local *FH;
  open FH, '<', '/proc/uptime'
    or die "$ME: failed to open /proc/uptime: $!\n";
  my $line = <FH>;
  my ($uptime) = $line =~ /^(\d+(?:\.\d+)?)/;
  return $uptime;
}

sub format_time ($)
{
  my @time = localtime $_[0];
  $time[4] += 1;
  $time[5] += 1900;
  return sprintf '%4i-%02i-%02i %02i:%02i:%02i', @time[reverse 0..5];
}

my $uptime = uptime ();
my $boot = time() - $uptime;

while (defined (my $line = <STDIN>))
  {
    $line =~ /\[\s*(\d+)\.\d+\](.*)/ or do { warn "OOPS\n"; print $line; next; };
    my $s = $1;
    my $readable = format_time($boot + $s);
    $line =~ s/\[[\s\d\.]+\]/\[$readable\]/;
    print $line;
  }
