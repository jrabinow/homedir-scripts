#!/usr/bin/env -S python
# -*- coding: utf-8 -*-

"""
dirdiff [OPTIONS...] dir1 dir2
modified files:
1 column
moved/renamed files:
2 columns
additional files:
1 column
"""

import argparse
import dataclasses
import hashlib
import json
import logging
import os
import stat
from collections import defaultdict
from contextlib import contextmanager
from pathlib import Path
from typing import Dict, List

LOG = logging.getLogger()
LOG.setLevel("INFO")
formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
ch = logging.StreamHandler()
ch.setFormatter(formatter)
LOG.addHandler(ch)

# types
HexDigest = str


@dataclasses.dataclass
class DirDiffFile:
    rootdir: Path
    position: Path
    hexdigest: str

    def __init__(self, rootdir: Path, path: Path):
        self.rootdir = rootdir
        self.position = path
        self.hexdigest = file_hexdigest(self.absolute)

    @property
    def absolute(self):
        return self.rootdir / self.position


class JsonEncoder(json.JSONEncoder):
    def default(self, o):
        if dataclasses.is_dataclass(o):
            d = dataclasses.asdict(o)
            d["path"] = o.absolute
            return d
        if isinstance(o, Path):
            return str(o)
        return super().default(o)


def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )
    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        help="enable debug logging information",
    )
    parser.add_argument(
        "--ignore-modified",
        action="store_true",
        help="don't show files that were modified",
    )
    parser.add_argument(
        "--ignore-moved",
        action="store_true",
        help="don't show files that were moved around",
    )
    parser.add_argument(
        "--ignore-additional",
        action="store_true",
        help="don't show files if they weren't either moved or modified",
    )
    parser.add_argument(
        "-s",
        "--silent",
        action="store_true",
        help="don't print modified/additional/moved section headers",
    )
    output_format = parser.add_mutually_exclusive_group()
    output_format.add_argument(
        "--json",
        action="store_true",
        help="display output as JSON",
    )
    parser.add_argument(
        "dirpath",
        type=Path,
        nargs="+",
        help="dir path",
    )
    args = parser.parse_args()
    if args.debug:
        LOG.setLevel(logging.DEBUG)
    return args


@contextmanager
def chdir(dirname):
    oldpwd = Path().absolute()
    try:
        os.chdir(dirname)
        yield
    finally:
        os.chdir(oldpwd)


def apply_to_dir(dirpath, func):
    return [
        dirpath / func(filepath)
        for filepath in Path(dirpath).rglob("*")
        if not filepath.is_dir()
    ]


def file_hexdigest(filepath):
    hasher = hashlib.sha1()
    BUFSIZ = 65536
    try:
        with open(filepath, "rb") as f:
            buf = f.read(BUFSIZ)
            while len(buf) > 0:
                hasher.update(buf)
                buf = f.read(BUFSIZ)
    except FileNotFoundError as e:
        # if this is a symlink
        if stat.S_ISLNK(os.lstat(filepath).st_mode):
            hasher.update(b"")
        else:
            raise
    except OSError as e:
        if e.errno == 102:
            hasher.update(b"")
        else:
            raise
    return hasher.hexdigest()


def preprocess_into_datastructs(rootdirs: List[Path]):
    # let's collect all the files from all the rootdirs and build our base data structures
    hashdiff_data: Dict[HexDigest, Dict[Path, List[DirDiffFile]]] = defaultdict(
        lambda: defaultdict(list)
    )
    pathdiff_data: Dict[Path, List[DirDiffFile]] = defaultdict(list)

    for rootdir in rootdirs:
        rootdir_path = Path(rootdir)
        with chdir(rootdir_path):
            filelist = apply_to_dir(".", lambda x: x)
        for f in filelist:
            try:
                ddf = DirDiffFile(rootdir_path, f)
                hashdiff_data[ddf.hexdigest][ddf.position].append(ddf)
                pathdiff_data[ddf.position].append(ddf)
            except PermissionError as e:
                LOG.warning(f"error processing {f}: {e}")

    return hashdiff_data, pathdiff_data


def partition_matched_unmatched(
    hashdiff_data: Dict[HexDigest, Dict[Path, List[DirDiffFile]]], rootdirs: List[Path]
):
    matched: Dict[HexDigest, List[DirDiffFile]] = defaultdict(list)
    unmatched: Dict[HexDigest, List[DirDiffFile]] = defaultdict(list)

    # dir1/foopath1/barfile1 is matched with dir2/foopath2/barfile2 if:
    #    - "foopath1" == "foopath2" and "barfile1" == "barfile2"
    #    - hash(barfile1) == hash(barfile2).
    # Otherwise, barfile1 is unmatched.
    len_rootdirs = len(rootdirs)
    for hexdigest, filedata in hashdiff_data.items():
        for _, filelist in filedata.items():
            if len(filelist) == len_rootdirs:
                assert (
                    len({f.rootdir for f in filelist}) == len_rootdirs
                    and len({f.hexdigest for f in filelist}) == 1
                    and len({f.position for f in filelist}) == 1
                ), ("matching error: %s" % filelist)
                matched[hexdigest].extend(filelist)
            else:
                for f in filelist:
                    unmatched[f.hexdigest].append(f)

    return matched, unmatched


def partition_unmatched_by_type(
    unmatched: Dict[HexDigest, List[DirDiffFile]],
    pathdiff_data: Dict[Path, List[DirDiffFile]],
    rootdirs: List[Path],
):
    # We distinguish 3 cases for unmatched files:
    #  - modified file
    #  - moved/renamed file
    #  - additional file
    #
    # dir1/foopath1/barfile1 was modified if:
    #  - dir2/foopath2/barfile2 with foopath1 == foopath2 exists
    #  - hash(barfile1) != hash(barfile2)
    # dir1/foopath1/barfile1 was moved/renamed if:
    #  - there exists dir2/foopath2/barfile2 such that foopath1 != foopath2 and hash(barfile1) == hash(barfile2)
    #  - neither barfile1 nor barfile2 are modified as per the definition above
    # dir1/foopath1/barfile1 is additional if:
    #  - barfile1 is not modified as per the definition above
    #  - barfile1 is not moved/renamed as per the definition above
    len_rootdirs = len(rootdirs)
    modified: Dict[Path, List[DirDiffFile]] = defaultdict(list)
    moved: List[List[DirDiffFile]] = []
    additional: List[DirDiffFile] = []

    for _, filelist in unmatched.items():
        unmodified = []
        for f in filelist:
            # if all rootdirs have a file at this position -> file was modified
            if len(pathdiff_data[f.position]) == len_rootdirs:
                modified[f.position].append(f)
            else:
                unmodified.append(f)
        # any unmodified file is either moved/renamed, or isn't in all rootdirs
        # all these files have the same hexdigest, and don't necessarily have the same path
        if len(unmodified) > 0:
            # if there's one file per repo, then at least one file was moved
            if len({f.rootdir for f in unmodified}) == len_rootdirs:
                moved.append(unmodified)
            # otherwise, who knows
            else:
                additional.extend(unmodified)

    return modified, moved, additional


def print_results(
    modified: Dict[Path, List[DirDiffFile]],
    moved: List[List[DirDiffFile]],
    additional: List[DirDiffFile],
    ignore_modified=False,
    ignore_moved=False,
    ignore_additional=False,
    json_output=False,
    silent=False,
):
    output_dict = {}
    if not ignore_modified:
        output_dict["modified"] = {str(k): v for k, v in modified.items()}
    if not ignore_moved:
        output_dict["moved"] = moved
    if not ignore_additional:
        output_dict["added"] = additional

    if json_output:
        print(json.dumps(output_dict, indent=2, cls=JsonEncoder))
    else:
        if not ignore_modified:
            if not silent:
                print("modified files:")
            for filepath in output_dict["modified"]:
                print(filepath)
        if not ignore_moved:
            if not silent:
                print("moved/renamed files:")
            for ren in output_dict["moved"]:
                moved_str = "\t".join([str(f.absolute) for f in ren])
                print(moved_str)
        if not ignore_additional:
            if not silent:
                print("additional files:")
            for add in output_dict["added"]:
                print(add.absolute)


def main():
    args = parse_args()

    hashdiff_data, pathdiff_data = preprocess_into_datastructs(args.dirpath)
    matched, unmatched = partition_matched_unmatched(hashdiff_data, args.dirpath)
    modified, moved, additional = partition_unmatched_by_type(
        unmatched, pathdiff_data, args.dirpath
    )
    print_results(
        modified,
        moved,
        additional,
        args.ignore_modified,
        args.ignore_moved,
        args.ignore_additional,
        args.json,
        args.silent,
    )


if __name__ == "__main__":
    main()
